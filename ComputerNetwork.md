# 计算机网络

通信系统模型：

![1536221850317](ComputerNetwork.assets/1536221850317.png)

## 第0周 计算机网络概述

计算机网络定义：**互连**的、**自治**的计算机集合。

计算机网络是**通信技术**与**计算机技术**紧密结合的产物。

Internet中**端系统**又叫做**主机**，采用的通信链路有**光纤**、**铜缆**、**无线电**、**卫星**，使用**分组交换**方式，**交换网络**中主要有**路由器**和**交换机**。

网络协议三要素：**语法**、**语义**、**时序（同步）**。

计算机网络结构：**网络边缘**、**接入网络**、**网络核心**。

### 网络核心

关键功能：**路由**、**转发**。

解决的基本问题：**数据交换**。

#### 数据交换的类型

- **电路交换**

  阶段：**建立连接**、**通信**、**释放连接**。

  独占/共享：**独占资源**。

  如何共享中继线：**多路复用**。

  多路复用的方法：**频分多路复用**、**时分多路复用**、**波分多路复用**、**码分多路复用**。

- **报文交换**

  一次发送一个信息整体。

  交换方式：**存储-转发**。

- **分组交换**

  需要报文的**拆分**与**重组**， 有**额外开销**。

  交换方式：**存储-转发**。

  如何共享中继线：**统计多路复用**。

分组交换适用于**突发数据传输网络**，允许更多用户同时使用网络，但可能产生拥塞（分组延迟和丢失）。

### 性能

- 速率（数据率、比特率）：单位时间传输信息量（bit）。往往指**额定速率**或**标称速率**。

- 带宽：**最高数据率**。

- 延迟（时延）

  丢包和时延原因：

  - 分组**到达速率超出输出链路容量**。
  - 分组排队，**等待输出链路可用**。

  分组延迟分类：**节点处理延迟**、**排队延迟**、**传输延迟**、**传播延迟**。

- 流量强度=分组长度×分组平均到达速率/链路带宽

  流量强度→0：**平均**排队延迟**很小**。

  流量强度→1：**平均**排队延迟**很大**。

  流量强度>1：超出服务能力，**平均**排队延迟**无限大**。

- 时延带宽积=传播时延×带宽

  又称**以比特为单位的链路长度**，可理解为同一时间内链路中可容纳（正在传播）的比特数。

- 分组丢失（丢包）

  原因：队列缓存容量有限，分组**到达已满队列**将被丢弃。

  丢包率=丢包数/已发分组总数

- 吞吐量（吞吐率）：**发送端与接收端之间**传送数据的速率。

  瓶颈链路：端到端路径上，**限制端到端吞吐量**的链路。

### 体系结构

计算机网络体系结构是从**功能上**描述计算机网络结构，是**分层结构**，每层遵循某个/些**网络协议**完成本层功能。下层协议的实现对上层的服务用户是**透明**的，同系统的相邻层实体间通过**接口**进行交互。

#### OSI参考模型（7层）（仅用于理论）

![1536227104531](ComputerNetwork.assets/1536227104531.png)

目的：支持**异构网络系统**的互联互通。

数据封装时添加的**控制信息**包括：

- **地址**：标识发送端/接收端。
- **差错检测编码**：用于查错及纠正。
- **协议控制**：协议附加信息。

各层功能：

- 物理层：适应接口特性（机械特性、电气特性、功能特性、规程特性），负责比特同步。

  **传输模式**有：

  - **单工**：仅某一方能向另一方发送信息，另一方仅能接受信息。
  - **半双工**：双方可互相发送和接收信息，但发送与接收不能同时进行。
  - **全双工**：双方可互相同时发送和接收信息。

- 数据链路层：负责**节点到节点数据传输**、**组帧**、**物理寻址**、**流量控制**、**差错控制**、**访问（接入）控制**。

- 网络层：负责**源主机到目的主机**数据分组交付、**逻辑寻址**、**路由**、**分组转发**。

- 传输层：负责端到端**进程**间的**完整报文**传输，职责包括**分段与重组**、**SAP寻址**（如端口号）、**连接控制**、**（端到端）流量控制**、**（端到端）差错控制**。

- 会话层：负责**对话控制**、**同步**（在数据流中插入同步点）。

- 表示层：处理两系统间信息的语法与语义问题，包括**数据表示转化**（编码转换）、**加密/解密**、**压缩/解压缩**。

- 应用层：支持用户通过**用户代理**（如浏览器）或**网络接口**使用网络（服务）。

  典型服务：**文件传输（FTP）**、**电子邮件（SMTP）**、**Web（HTTP）**。

#### TCP/IP参考模型（5层）（多用于实践）

各层典型协议：

- 应用层：**FTP**、**SMTP**、**HTTP**。
- 传输层：**TCP**、**UDP**。
- 网络层：**IP协议**、**路由协议**。
- 链路层：**以太网**、**802.11**（WiFi）、**PPP**。
- 物理层：无。

**主机**通常为**应用层设备**；**路由器**通常为**网络层设备**；**交换机**通常为**数据链路层设备**。

### 例题

#### 题目

> 在如图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为100Mbps，分组大小为1000B， 其中分组头大小为20B。若主机H1向主机H2发送一个大小为980000B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H1发送开始到H2接收完位置，需要的时间至少是多少？
>
> ![1536223542016](ComputerNetwork.assets/1536223542016.png)

#### 题解

980 000 B的文件需要分1000个分组，每分组1000B。

H1发送整个文件的传输延迟为(980000+20×1000)×8/100000000=80ms

最后一个分组的两次转发传输延迟为2×1000×8/100000000=0.16ms

总用时为80+0.16=80.16ms。

## 第1-2周 网络应用

### 体系结构

- **客户机/服务器**（C/S）结构

  服务器特点：

  - 7*24小时提供服务（**持久接入网络**）
  - **永久性**的可访问地址/域名
  - 利用**大量服务器**实现**可扩展性**

  客户机特点：

  - **间歇性**接入网络
  - 可能使用**动态IP**地址
  - **不会与其它客户机直接通信**

  典型例子：Web。

- **点对点**（P2P）结构

  特点：

  - **没有永远在线**的服务器
  - 任意端系统/节点之间可**直接**通讯
  - 节点**间歇性**接入网络
  - 节点可能使用**动态IP**地址

  优点：高度**可伸缩**。

  缺点：**难于管理**。

- **混合**（Hybrid）结构

  典型例子：Napster

  - 文件传输使用P2P结构。
  - 查询使用C/S结构。

### 网络应用进程通信

不同主机上运行的进程间使用**消息交换（报文交换）**进行通信。发起通信的进程称为**客户机进程**，等待通信请求的进程称为**服务器进程**。**这两个概念在P2P结构中也存在。**

**套接字**（Socket）：**操作系统**提供的用于**网络通信**的API。

进程寻址：为了唯一确定另一主机上的一个进程，需要该**主机的IP地址**+该**进程分配到的端口号**作为该进程的标识符。

#### 应用层协议

公开协议：由**RFC**（Request For Comments）定义，允许**互操作**。

私有协议：自行设计的，不公开的协议。

##### 内容

- **消息的类型**
- **消息的语法**（格式）：消息中有哪些字段，每个字段如何描述。
- **字段的语义**：字段中信息的含义
- **规则**：进程发送消息的规则，例如何时发送/怎样发送等。

### 传输服务

#### 网络应用对传输的需求

- **数据丢失/可靠性**：某些网络应用能够容忍一定程度的数据丢失（如网络电话），另一些要求100%可靠的数据传输（如文件传输）。
- **时间/延迟**：某些网络应用仅在延迟足够低时才有效（如网络游戏）。
- **带宽**：某些应用只有在带宽达到最低要求时才有效，另一些则能适应任何带宽（如email）。

#### Internet提供的传输服务

- **TCP服务**

  - 面向**连接**：客户机/服务器进程间需要建立连接。 

  - **可靠**传输：保证数据正确，不丢包。
  - 流量控制
  - 拥塞控制
  - **不提供时间/延迟保障**
  - **不提供最小带宽保障**

- **UDP服务**

  - **无连接**
  - **不可靠**的数据传输
  - 不提供流量控制、拥塞控制、延迟保障、带宽保障。

### Web应用

万维网（World Wide Web）的主体是**互相链接的网页**。网页包含多个**对象**（HTML文件、JPEG图片等），基本HTML文件包含对其他**对象**引用的**链接**。

**统一资源定位器**（URL）：用于**对象的寻址**。格式为`scheme://host:port/path`，其中`scheme`为协议，`host`为主机地址（域名或IP地址），`port`为端口号，`path`为资源在主机上的路径。

#### 超文本传输协议（HTTP）

- 结构：**C/S结构**。

- 传输服务：**TCP服务**。
- 端口：**80**
- 特点：HTTP是无状态协议，即服务器不维护任何有关客户端过去所发请求的信息。

##### 连接类型

- HTTP 1.0版本使用**非持久性连接**，即每个TCP连接最多允许传输**一个**对象。

  示例：

  ![1536245377353](ComputerNetwork.assets/1536245377353.png)

- HTTP 1.1版本默认使用**持久性连接**，即每个TCP连接允许传输**多个**对象。

##### 响应时间分析

RTT(Round Trip Time)：从客户端发送一个很小的数据包到服务器并返回所经历的时间。

- 非持久性连接：

  1. 发起、建立TCP连接：1个RTT
  2. 发送HTTP请求消息到HTTP响应消息到达：1个RTT
  3. 响应消息中的对象传输时间

  每对象总时间=2×RTT+文件发送时间

- 持久性连接：

  - 无流水机制时，客户端只有**收到前一个响应后**才发送新请求，每个被引用对象耗时1个RTT。

    每对象总时间=RTT+文件发送时间

  - 有流水机制时（HTTP1.1默认），客户端只要遇到引用对象就尽快发送请求，理想情况下所有对象共耗时1个RTT。

    每对象总时间=RTT/对象个数+文件发送时间

##### 消息格式

- **请求消息**

  - 使用**ASCII码**书写

  - 方法：

    - **GET**(HTTP 1.0/1.1)：用于请求对象。
    - **POST**(HTTP 1.0/1.1)：在数据体中上传客户端的输入，如需填写的表格。
    - **URL**：实际使用**GET**方法，输入信息通过URL上传。
    - **HEAD**(HTTP 1.0/1.1)：请Server不要将所请求的对象放入响应消息中。
    - **PUT**(HTTP 1.1)：将消息体中文件上传到URL字段指定的路径。
    - **DELETE**(HTTP 1.1)：删除URL字段指定的文件。

  - 通用格式：（第1行称为“请求行”，第2-5行可扩展，称为“头部行”）

    ```
    方法 URL 版本
    头字段名: 值
    头字段名: 值
    ……
    头字段名: 值
    
    数据体
    ```

  - 示例：

    ```http
    GET /somedir/page.html HTTP/1.1
    Host: www.someschool.edu
    User-agent: Mozilla/4.0
    Connection: close
    Accept-language: fr
    (empty line)
    (extra carriage)
    ```

- **响应消息**

  - 常见响应状态代码

    | 代码 | 描述                       |
    | ---- | -------------------------- |
    | 200  | OK                         |
    | 301  | Moved Permanently          |
    | 400  | Bad Request                |
    | 404  | Not Found                  |
    | 505  | HTTP Version Not Supported |

  - 通用格式：（第1行称为“状态行”，第2-5行可扩展，称为“头部行”）

    ```
    版本 状态码 状态描述
    头字段名: 值
    头字段名: 值
    ……
    头字段名: 值
    
    数据体
    ```

  - 示例：

    ```http
    HTTP/1.1 200 OK
    Connection: close
    Date: Thu, 06 Aug 1998 12:00:15 GMT
    Server: Apache/1.3.0 (Unix)
    Last-Modified: Mon, 22 Jun 1998 ......
    Content-Length: 6821
    Content-Type: text/html
    (empty line)
    (data)
    ```

#### Cookie

定义：某些网站为了**辨别用户身份**、**进行会话跟踪**而储存在用户**本地终端**上的数据（通常**经过加密**）。

组件：

- HTTP响应消息的cookie头部行
- HTTP请求消息的cookie头部行
- 保存在客户端主机上的cookie文件，由浏览器管理
- Web服务器端的后台数据库

作用：身份认证、购物车、推荐、Web email等

#### Web缓存/代理服务器

功能：在**不访问服务器**的前提下满足客户端的HTTP请求。

作用：

- 缩短客户请求的响应时间
- 减少机构/组织的流量
- 实现大范围内有效的内容分发

##### 缓存内容与远端不一致问题

**条件性GET**方法：代理服务器在HTTP请求中声明**持有版本的修改日期**，若在修改日期后有新版本，则服务器返回**200 OK**及**新版本对象**，否则返回**304 Not Modified**。

### Email应用

#### 组件

- **邮件客户端**：读写Email消息，与服务器交互收发Email消息。
- **邮件服务器**：维护**邮箱**（存储发送给该用户的Email）和**消息队列**（存储等待发送的Email）。
- **SMTP**（Simple Mail Transfer Protocol）：用于邮件服务器之间传递消息。客户端为发送消息的服务器；服务器为接收消息的服务器。

#### SMTP协议（邮件发送协议）

- 传输服务：**TCP**

- 端口：**25**

- 阶段：**握手**；**消息传输**；**关闭**。

- 消息格式

  Email消息仅能包含**7位ASCII码**。使用`CRLF.CRLF`确定消息结束。

  - **命令**消息：ASCII文本
  - **响应**消息：状态代码和语句

- 交互示例：

  ```
  Server: 220 hamburger.edu
  Client: HELO crepes.fr
  Server: 250  Hello crepes.fr, pleased to meet you
  (Connection opened)
  Client: MAIL FROM: <alice@crepes.fr>
  Server: 250 alice@crepes.fr ... Sender ok
  Client: RCPT TO: <bob@hamburger.edu>
  Server: 250 bob@hamburger.edu ... Recipient ok
  Client: DATA
  Server: 354 Enter mail, end with "." on a line by itself
  Client: Do you like ketchup?
  Client: How about pickles?
  Client: .
  Server: 250 Message accepted for delivery
  Client: QUIT
  Server: 221 hamburger.edu closing connection
  (Connection closed)
  ```

- Email消息格式：

  - 头部行（header）：To，From，Subject。
  - 消息体（body）：消息本身，只能是ASCII字符。

- **多媒体邮件扩展**（**MIME**）

  通过在邮件头部增加额外行以声明MIME内容类型。

  格式：

  ```
  From: 发件人
  To: 收件人
  Subject: 主题
  MIME-Version: MIME版本号
  Content-Transfer-Encoding: 数据编码方法（如base64）
  Content-Type: 多媒体数据类型，子类型及参数声明（如image/jpeg）
  
  编码后的数据
  ```

#### 邮件访问协议

**POP**、**IMAP**、**HTTP**都可作为邮件访问协议。

##### POP3协议

- 有无状态：**无状态**

- 命令

  - 认证阶段：
    - 客户端命令：User声明用户名、Pass声明密码
    - 服务器响应：+OK表示合法用户、-ERR表示非法用户或密码错误。
  - 事务阶段：
    - List列出消息数量
    - Retr用编号获取消息
    - Dele删除消息
    - Quit退出

- 模式

  - 下载并删除：用户如果切换客户端将**无法重读邮件**。
  - 下载并保持：不同客户端都可以**保留消息拷贝**。

- 示例：

  ```
  (认证阶段)
  Server: +OK POP3 server ready
  Client: user bob
  Server: +OK
  Client: pass hungry
  Server: +OK user successfully logged on
  (事务阶段)
  Client: list
  Server: 1 498
  Server: 2 912
  Server: .
  Client: retr 1
  Server: <message 1 contents>
  Server: .
  Client: dele 1
  Client: retr 2
  Server: <message 1 contents>
  Server: .
  Client: dele 2
  Client: quit
  Server: +OK POP3 server signing off
  ```

##### IMAP协议

- 所有消息统一保存在**服务器**。
- 允许利用**文件夹**组织消息。
- 有无状态：支持**跨会话**的用户状态，包括文件夹的名字、文件夹与消息ID间的映射等。

### DNS应用

定义：由**多层命名服务器**构成的**分布式数据库**，是**应用层**协议。

目的：解决**Internet**上**主机/路由器**的识别问题，即**解析域名**，**映射至IP地址**。

集中式DNS的问题：**单点失败**问题、**流量**问题、**距离**问题、**维护性**问题。总之，是**不可伸缩**问题。

DNS服务：域名向IP地址的翻译、主机/邮件服务器别名、负载均衡（Web服务器）。

#### DNS服务器层次

1. **根域名服务器**

   **本地域名服务器**无法解析域名时，访问**根域名服务器**。全球有13个根域名服务器（**中国没有**）。

   工作流程：

   1. 若不知道映射，则访问顶级域名服务器**获得映射**。
   2. 向本地域名服务器**返回映射**。

2. **顶级域名服务器**（TLD）

   负责`com`，`org`，`net`，`edu`等顶级域名和`cn`，`uk`，`fr`等国家顶级域名。

   Network Solutions（公司）维护`com`顶级域名服务器

   Educause维护`edu`顶级域名服务器。

3. **权威域名服务器**

   提供组织内部服务器的解析服务。由组织或服务提供商维护。

4. **本地域名服务器**（不严格属于层次体系）

   每个**ISP**有一个本地域名服务器，也称默认域名解析服务器。

   主机进行DNS查询时，查询被发送至本地域名服务器。其作为**代理**将查询转发给**层级中的域名服务器**。

#### DNS查询方式

- **迭代查询**：被查询服务器**返回域名解析服务器名字**，以作为新的被查询服务器。
- **递归查询**：被查询服务器必须**查询到解析结果**，之后**返回结果**。

#### 查询示例

查询`www.amazon.com`的IP地址：

1. 查询根服务器，找到`com`域名解析服务器。
2. 查询`com`域名解析服务器，找到`amazon.com`域名解析服务器。
3. 查询`amazon.com`域名解析服务器，获得`www.amazon.com`的IP地址。

#### DNS缓存

- 域名解析服务器每获得一**域名-IP映射**，即**缓存**之。一段时间过后，缓存条目失效。
- **本地域名服务器**一般会缓存**顶级域名服务器**的映射。（因此根域名服务器**不常被访问**）

#### DNS记录格式

DNS记录称为**资源记录**。格式为`(name, value, type, ttl)`。`type`取值不同将影响`name`和`value`的语义。

##### 类型（type取值）

- A（主机域名解析服务）
  - Name：主机域名
  - Value：IP地址
- NS（域解析服务）
  - Name：域（如`edu.cn`）
  - Value：该域**权威域名服务器**的主机**域名**。

- CNAME（别名服务）
  - Name：某真实域名的**别名**
  - Value：真实域名
- MX（邮件服务器别名服务）
  - Name：域名
  - Value：与Name对应的邮件服务器

#### DNS协议消息格式

**查询消息**与**回复消息**格式**相同**。

- 消息头部
  - Identification：16位**查询编号**，回复时使用**相同编号**。
  - flags：**标志位**，例如标志查询或回复、是否期望递归、递归是否可用、是否权威回答等。
  - 问题数目、回答数目等
- 消息体
  - 问题内容、回答内容等

#### 怎样注册域名

假设公司名为"Network Utopia"。

1. 在域名管理机构注册域名`networkutopia.com`。

   域名管理机构向`com`顶级域名服务器中插入记录

   ```
   (networkutopia.com, dns1.networkutopia.com, NS)
   (dns1.networkutopia.com, 212.212.212.1, A)
   ```

2. 在权威域名解析服务器`dns1.networkutopia.com`中为`www.networkutopia.com`加入Type A记录。

   为`networkutopia.com`加入Type MX记录。

### P2P应用

#### P2P架构

- **无服务器**
- 端系统间**直接通信**
- 节点**阶段性**接入Internet
- 节点**可能更换IP**地址

#### BitTorrent协议

**tracker**：跟踪参与**torrent**的节点。

**torrent**：交换**同一个文件**的文件块的**节点组**。

##### 内容

- 文件被划分为256KB的**chunk**。
- 一个节点加入torrent后向tracker**注册**以**获得节点清单**，并与某些节点（邻居）**建立连接**。
- 下载的同时，节点需要**向其他节点上传**chunk。
- 一旦节点获得完整的文件，节点既可以留下保持上传，也可以离开。

##### 优化策略

- 节点定期查询每个邻居持有的chunk列表，优先获取**稀缺**的chunk。
- 节点为**下载速率最快**的4个节点提供上传服务，且**每10秒重新评估**一次。
- **不论下载速度如何**，节点总与某个peer保持疏通（为该peer提供上传），该peer称为**optimistic unchoking**。这是为了在空闲连接中发现下载速度更大的连接（结合上一条）。optimistic unchoking每30秒重新选择一次。

#### 索引技术

**索引**：信息到节点位置（**IP地址+端口号**）的映射。

##### 集中式索引

- 建立索引：节点加入时，将自身内容和位置通知中央服务器建立索引。
- 查询索引：直接询问中央服务器。

- 特点：内容和文件传输是**分布式**的，内容定位是**高度集中式**的。
- 问题：**单点失效**、**性能瓶颈**、**版权**等。

##### 洪泛式查询

**覆盖网络**：节点及其间**TCP连接**构成的图。

- 建立索引：每个节点**对且仅对它共享的文件**进行索引。

- 查询索引：通过**已有TCP连接**发送查询，其它节点**转发**查询消息。若查询命中，则利用**反向路径**发回查询节点。

##### 层次式覆盖网络

每个节点或是**超级节点**，或被**分配**一个超级节点。节点与超级节点间维持TCP连接，某些超级节点对间维持TCP连接。

- 建立索引：超级节点负责**跟踪**子节点的内容。
- 查询索引：节点**向超级节点发送查询消息**，超级节点间进行**洪泛式查询**。
- 示例：Skype
  - 索引维护用户名与IP地址间的映射，分布在超级节点上。
  - 协议**本质是P2P**的，用户/节点对之间直接通信。

### Socket编程

Socket是定义在**应用层**与**传输层**间的网络应用编程接口。

Berkeley Unix中套接字称为**socket**；Windows中**套接字接口与前者稍有不同**，称为**WINSOCK**；AT&T Unix（V）中套接字称为**TLI**。

#### 架构

- 通信模型：**C/S**。

- 通信端点标识：**IP地址+端口号**（外部）；**套接字描述符（小整数）**（操作系统）。

- Socket抽象：类似于**文件**的抽象，由**套接字描述符**指代，指向操作系统分配的一个数据结构。

- 地址结构：

  ```c
  struct sockaddr_in
  {
      u_char sin_len;          /*地址长度*/
      u_char sin_family;       /*地址族（标识地址的类型，例如TCP/IP为AF_INET）*/
      u_short sin_port;        /*端口号*/
      struct in_addr sin_addr; /*IP地址*/
      char sin_zero[8];        /*未使用（置0）*/
  }
  ```

#### Socket API（以WinSock为例）

- WSAStartup：初始化Windows Sockets API。

  - 原型：

    ```c
    int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
    ```

  - 参数1指明程序请求使用的WinSock版本，其中高位字节指明副版本，低位字节指明主版本。例如0x102表示2.1版。

  - 参数2是指向WSADATA结构的指针，用于返回实际的WinSock版本信息。

  - 示例：

    ```c
    wVersionRequested = MAKEWORD(2, 1);
    err = WSAStartup(wVersionRequested, &wsaData);
    ```

- WSACleanup：释放所使用的Windows Sockets DLL及其占用的资源。

  - 原型：

    ```c
    int WSACleanup(void);
    ```

- socket：创建套接字，返回套接字描述符（sd）。

  - 原型：

    ```c
    SOCKET socket(int protofamily, int type, int proto);
    ```

  - 参数1指明协议族，例如TCP/IP为`PF_INET`。

  - 参数2指明套接字类型，可取值`SOCK_STREAM`（**流式套接字**，面向TCP），`SOCK_DGRAM`（**数据报套接字**，面向UDP）或`SOCK_RAW`（**原始套接字**，需要特殊权限，**直接面向网络层**）。

    其中，TCP协议提供**可靠**、**面向连接**、**字节流传输**、**点对点**、**全双工**的传输服务；UDP提供**不可靠**、**无连接**、**数据报传输**的传输服务。

  - 参数3指明协议号，0表示该类型套接字的默认协议。

  - 示例（创建一个面向TCP/IP的流式套接字）：

    ```c
    struct protoent *p;
    p = getprotobyname("tcp");
    SOCKET sd = socket(PF_INET, SOCK_STREAM, p->p_proto);
    ```

- closesocket：关闭一个套接字。

  - 原型：

    ```c
    int closesocket(SOCKET sd);
    ```

  - 注意事项：若**多进程共享**一个套接字，该函数每次调用会将**套接字引用计数减1**，减至0才关闭；若一进程中的**多线程共享**一个套接字，当某线程关闭该套接字时，**其余线程也无法访问该套接字**。

- bind：绑定套接字的本地端点地址（IP地址+端口号）。

  - 原型：

    ```c
    int bind(SOCKET sd, const struct sockaddr_in *localaddr, int addrlen);
    ```

  - 参数1指明套接字。

  - 参数2指明端点地址。

  - 注意事项：客户程序一般不必调用该函数（操作系统自动设置）；服务器端需调用该函数绑定熟知端口号。当一个套接字需绑定多个IP地址时，使用地址通配符`INADDR_ANY`以绑定**任意合法IP**。

- listen：置**服务器端**的**流套接字**处于监听状态。（仅**服务器端**可用）

  - 原型：

    ```c
    int listen(SOCKET sd, int queuesize);
    ```

  - 参数1指明套接字。

  - 参数2指明连接请求队列大小。

- connect：使套接字与特定计算机的特定端口的套接字进行连接。（仅**客户端**可用）

  - 原型：

    ```c
    int connect(SOCKET sd, const struct sockaddr_in *saddr, int saddrlen);
    ```

  - 参数1指明套接字。

  - 参数2指明要连接的端点地址。

  - 注意事项：该函数既可用于TCP客户端（**建立TCP连接**）也可用于UDP客户端（**指定服务器端点地址**）。

- accept：从**监听状态套接字**的请求队列中取出**队首请求**，并创建**新套接字**与其**建立连接**。（仅**TCP服务器**可用）

  - 原型：

    ```c
    SOCKET accept(SOCKET sd, struct sockaddr_in *caddr, int caddrlen);
    ```

  - 参数1指明监听状态套接字。

  - 参数2用于返回客户端套接字的端点地址。

- send, sendto：通过套接字发送数据。

  - 原型：

    ```c
    int send(SOCKET sd, const char *buf, int len, int flags);
    int sendto(SOCKET sd, const char *buf, int len, int flags, const sockaddr_in *destaddr, int addrlen);
    ```

  - 注意事项：`send`函数用于TCP套接字或调用了`connect`函数的UDP客户端套接字；`sendto`函数用于UDP服务器端套接字或未调用`connect`函数的UDP客户端套接字。

- recv, recvfrom：通过套接字接收数据。

  - 原型：

    ```c
    int recv(SOCKET sd, char *buffer, int len, int flags);
    int recvfrom(SOCKET sd, char *buf, int len, int flags, sockaddr_in *senderaddr, int saddrlen);
    ```

  - 注意事项：`recv`函数用于从TCP套接字或调用了`connect`函数的UDP客户端套接字接收数据；`recvfrom`函数用于从UDP服务器端套接字或未调用`connect`函数的UDP客户端套接字接收数据。

- setsockopt, getsockopt：设置/获取套接字的选项参数。（略）

- htons, ntohs, htonl, ntohl：本地字节顺序/网络字节顺序转换。（略）

- inet_addr, gethostbyname：点分十进制IP地址/域名到32位IP地址的转换。（略）

- getservbyname：服务名（如`HTTP`）到熟知端口号的转换。（略）

- getprotobyname：协议名到协议号的转换。（略）

#### 客户端软件设计

##### TCP客户端软件流程

1. 确定**服务器IP地址与端口号**。
2. 创建**套接字**。
3. 分配本地端点地址（IP地址+端口号）。（**系统自动完成**）
4. **连接服务器**（套接字）。
5. 遵循**应用层协议**进行通信。
6. 关闭/**释放连接**。

##### UDP客户端软件流程

1. 确定**服务器IP地址与端口号**。
2. 创建**套接字**。
3. 分配本地端点地址（IP地址+端口号）。（**系统自动完成**）
4. 指定**服务器端点地址**，构造UDP数据报。
5. 遵循**应用层协议**进行通信。
6. 关闭/**释放连接**。

#### 服务器软件设计

**循环**：顺序依次处理客户请求。

**并发**：同时处理多客户请求。

##### 循环无连接服务器

1. **创建套接字**。
2. **绑定端点地址**（`INADDR_ANY`+端口号）。
3. 反复**接收来自客户端的请求**。（每收到一个请求即转到步骤4）
4. 遵循应用层协议，构造**响应报文**，发送给客户。（之后返回步骤3）

##### 循环面向连接服务器

1. **创建（主）套接字**，并**绑定熟知端口号**。
2. 设置（主）套接字为**被动监听**模式，准备用于服务器。
3. 调用`accept()`函数（通过主套接字）**接收下一个连接请求**，**创建新套接字**用于与该客户建立连接。
4. 遵循应用层协议，反复**接收客户请求**，构造并（通过新套接字）发送**响应报文**。
5. 完成为特定客户服务后，**关闭与该客户之间的连接**，返回步骤3。

##### 并发无连接服务器

- 主线程：
  1. **创建套接字**，并**绑定熟知端口号**。
  2. 反复调用`recvfrom()`函数，**接收下一个客户请求**，并**创建新线程**处理该客户响应。
- 子线程：
  1. **接收**一个特定请求。
  2. 遵循应用层协议构造**响应报文**，并调用`sendto()`发送。
  3. **退出**。（一个子线程处理**一个请求**后即终止）

##### 并发面向连接服务器

- 主线程：
  1. **创建（主）套接字**，并**绑定熟知端口号**。
  2. 设置（主）套接字为**被动监听**模式，准备用于服务器。
  3. 反复调用`accept()`函数（通过主套接字）**接收下一个连接请求**，并**创建一个新的子线程**处理该客户响应。
- 子线程：
  1. （通过新创建的套接字）**接收**一个客户的服务请求。
  2. 遵循应用层协议，反复**接收客户请求**，构造并（通过新套接字）发送**响应报文**。
  3. **关闭/释放连接**并退出。（**线程终止**）

### 例题

#### 题目

> 如果本地域名服务器无缓存，当采用递归方法解析另一网络某主机域名时，用户主机、本地域名服务器发送的域名请求消息数分别为
>
> A. 一条、一条
>
> B. 一条、多条
>
> C. 多条、一条
>
> D. 多条、多条

#### 题解

由于采用递归方法，

本地域名服务器**代理**后续查询，因此主机仅发送1条。

本地域名服务器无缓存，因此向另一域名服务器发送查询请求，被查询服务器**代理**后续查询，因此本地域名服务器仅发送1条。

故选A.

#### 题目

> 从一个服务器向N个节点分发一个长度为F的文件需要多长时间？分别就C/S结构与P2P结构进行分析。
>
> 已知服务器上传带宽为us，节点i的上传带宽为ui，下载带宽为di。

#### 题解

- 采用C/S结构：

  服务器需串行地发送N个副本，共需时间NF/us；每个客户端需要F/di的时间下载。

  故最短时间为max(NF/us, F/di)。

- 采用P2P结构：

  服务器至少发送1个副本，所需时间为F/us；每个客户端需要F/di的时间下载；所有主机总共需要上传的比特数为NF，而所有主机最快上传速率之和为us+sum(ui)。

  故最短时间为max(F/us, F/di, NF/(us+sum(ui)))。